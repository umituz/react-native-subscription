# Presentation Layer

UI/UX layer for the subscription system - React hooks, components, and screens.

## Location

**Directory**: `src/presentation/`

**Type**: Layer

## Strategy

### Layer Responsibilities

The Presentation Layer is responsible for:

1. **State Management**
   - React hooks for data fetching and mutations
   - TanStack Query for server state management
   - Local state management for UI state

2. **UI Components**
   - Reusable subscription components
   - Feature gating UI elements
   - Credit display components
   - Paywall components

3. **User Interaction**
   - Handle user actions
   - Display appropriate feedback
   - Guide users through purchase flows
   - Show upgrade prompts at right time

### Architecture Pattern

The presentation layer follows a layered architecture where:
- Hooks manage state and data fetching at the top level
- Components consume hooks and render UI
- Screens compose multiple components together
- All layers communicate with the domain layer for business logic

### Integration Points

- **Domain Layer**: Business logic and data access
- **TanStack Query**: Server state management
- **RevenueCat**: Purchase operations
- **Navigation**: Screen routing

## Restrictions

### REQUIRED

- **Type Safety**: All components MUST be typed with TypeScript
- **Error Boundaries**: MUST implement error boundaries for all screens
- **Loading States**: MUST show loading indicators during async operations
- **User Feedback**: MUST provide feedback for all user actions

### PROHIBITED

- **NEVER** include business logic in components (use hooks instead)
- **NEVER** make direct API calls from components (use hooks)
- **DO NOT** store sensitive data in component state
- **NEVER** hardcode strings (use localization)

### CRITICAL SAFETY

- **ALWAYS** validate props before rendering
- **ALWAYS** handle loading and error states
- **NEVER** trust client-side state for security decisions
- **MUST** implement proper error boundaries
- **ALWAYS** sanitize user inputs before display

## Rules

### Component Structure

**CORRECT**: Proper component structure includes:
- Define TypeScript interface for props
- Import and use appropriate hooks for data fetching
- Return loading indicator when data is fetching
- Return error display when there's an error
- Render actual component only when data is available

**INCORRECT**: No loading/error handling
- Don't render component without checking if data is loading
- Don't display component without handling potential errors
- Never assume data is always available immediately

**INCORRECT**: Business logic in component
- Don't use useEffect to fetch data directly
- Don't manage complex state with useState for business logic
- Never include data transformation logic in components

### Hook Usage

**CORRECT**: Use hooks for data fetching
- Call useCredits to get credit balance with loading and error states
- Call usePremium to check premium status
- Always check if loading is true before rendering
- Always check if error exists before rendering

**INCORRECT**: Direct API calls in component
- Don't use useEffect with axios or fetch to call APIs
- Don't manage async operations manually in components
- Never handle API responses directly in UI components

### Error Boundaries

**CORRECT**: Wrap screens with error boundaries
- Import ErrorBoundary component
- Create fallback error screen component
- Wrap screen content with ErrorBoundary component
- Pass fallback component to ErrorBoundary

**INCORRECT**: No error boundary
- Don't export screens without error boundary wrapper
- Never let errors crash entire application
- Don't assume components will never throw errors

## AI Agent Guidelines

### When Building Presentation Layer

1. **Always** use hooks for data fetching and state management
2. **Always** handle loading and error states
3. **Always** provide user feedback for actions
4. **Always** implement error boundaries
5. **Never** include business logic in components

### Integration Checklist

- [ ] Use appropriate hooks for data access
- [ ] Handle loading states
- [ ] Handle error states
- [ ] Implement error boundaries
- [ ] Provide user feedback
- [ ] Test with various data states
- [ ] Test error scenarios
- [ ] Ensure type safety
- [ ] Use localization for all strings
- [ ] Test accessibility

### Common Patterns

1. **Compound Components**: Build complex UIs from simple components
2. **Render Props**: Share stateful logic between components
3. **Custom Hooks**: Extract reusable stateful logic
4. **Error Boundaries**: Prevent crashes from propagating
5. **Loading Skeletons**: Show placeholder during loading
6. **Optimistic Updates**: Update UI immediately, rollback on failure
7. **Graceful Degradation**: Show limited version on error
8. **Responsive Design**: Support different screen sizes

## Related Documentation

- **Hooks**: `hooks/README.md`
- **Components**: `components/README.md`
- **Screens**: `screens/README.md`
- **Wallet Domain**: `../../domains/wallet/README.md`
- **Paywall Domain**: `../../domains/paywall/README.md`
- **RevenueCat**: `../../revenuecat/README.md`

## Directory Structure

The presentation layer contains:
- **hooks/** - React hooks for state management (usePremium, useSubscription, useCredits, useDeductCredit, useFeatureGate)
- **components/** - UI components organized by functionality
  - **details/** - Detail cards, badges
  - **feedback/** - Modals, feedback components
  - **sections/** - Section components
  - **paywall/** - Paywall components
- **screens/** - Full-screen components (SubscriptionDetailScreen)
