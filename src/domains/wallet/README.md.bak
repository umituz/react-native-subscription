# Wallet Domain

Credit balance management, transaction history tracking, and product metadata management.

## Location

**Directory**: `src/domains/wallet/`

**Type**: Domain

## Strategy

### Domain Architecture

The Wallet Domain implements a layered architecture for credit management:

1. **Domain Layer**
   - Entities: `UserCredits`, `Transaction`, `CreditType`
   - Value Objects: `CreditAmount`, `TransactionReason`
   - Errors: `InsufficientCreditsError`, `InvalidCreditAmountError`

2. **Infrastructure Layer**
   - Repositories: `CreditsRepository`, `TransactionsRepository`
   - Firebase Services: Data persistence and real-time updates
   - Mappers: Entity ↔ DTO transformations

3. **Presentation Layer**
   - Hooks: `useCredits`, `useDeductCredit`, `useInitializeCredits`
   - Components: Credit displays, transaction lists

### Credit Flow

1. **Initialization**
   - Fetch initial credit balance from backend
   - Subscribe to real-time credit updates
   - Cache in TanStack Query

2. **Operations**
   - Check balance before operations
   - Deduct credits optimistically
   - Sync with backend
   - Rollback on failure

3. **Transaction History**
   - Record all credit operations
   - Provide audit trail
   - Support pagination and filtering

### Integration Points

- **Firebase**: Real database for persistence
- **TanStack Query**: Client-side caching and state management
- **RevenueCat**: Purchase flow integration
- **Presentation Hooks**: UI integration layer

## Restrictions

### REQUIRED

- **User Authentication**: All operations require authenticated user
- **Server Validation**: Credit operations MUST be validated server-side
- **Transaction Recording**: All credit changes MUST be recorded in transaction history
- **Error Handling**: MUST handle insufficient credits gracefully

### PROHIBITED

- **NEVER** allow client-side credit modifications without server validation
- **NEVER** deduct credits without sufficient balance
- **DO NOT** expose internal repository logic to UI
- **NEVER** store credit balance in AsyncStorage (use secure backend)

### CRITICAL SAFETY

- **ALWAYS** validate credit amounts (must be positive)
- **ALWAYS** implement optimistic updates with rollback
- **NEVER** trust client-side credit balance for security decisions
- **MUST** implement retry logic for failed operations
- **ALWAYS** sanitize transaction reasons to prevent injection attacks

## Rules

### Repository Initialization

```typescript
// CORRECT - Proper repository setup
const creditsRepository = new CreditsRepository({
  firebase: firebaseInstance,
  userId: user.uid,
});

// INCORRECT - Missing userId
const creditsRepository = new CreditsRepository({
  firebase: firebaseInstance,
  // userId undefined
});
```

### Credit Operations

```typescript
// CORRECT - Check before deduct
const hasEnoughCredits = await creditsRepository.checkBalance(requiredAmount);
if (hasEnoughCredits) {
  await creditsRepository.deductCredits(requiredAmount, 'feature_usage');
}

// INCORRECT - Deduct without checking
await creditsRepository.deductCredits(requiredAmount, 'feature_usage');
// May throw InsufficientCreditsError
```

### Transaction Recording

```typescript
// CORRECT - Record all operations
await creditsRepository.deductCredits(
  amount,
  reason,
  { featureId, metadata } // Include context
);

// INCORRECT - Missing context
await creditsRepository.deductCredits(amount, reason);
// Lost audit trail
```

### Error Handling

```typescript
// CORRECT - Handle specific errors
try {
  await creditsRepository.deductCredits(amount, reason);
} catch (error) {
  if (error instanceof InsufficientCreditsError) {
    showUpgradePrompt();
  } else if (error instanceof InvalidCreditAmountError) {
    showInvalidAmountError();
  } else {
    showGenericError();
  }
}

// INCORRECT - Generic error handling
try {
  await creditsRepository.deductCredits(amount, reason);
} catch (error) {
  console.error(error); // Doesn't help user
}
```

## AI Agent Guidelines

### When Implementing Credit Operations

1. **Always** check balance before deducting
2. **Always** provide transaction reason and metadata
3. **Always** handle insufficient credits gracefully
4. **Always** implement optimistic updates with rollback
5. **Never** trust client-side balance for security

### Integration Checklist

- [ ] Initialize repository with valid userId
- [ ] Implement error boundaries
- [ ] Handle loading states
- [ ] Provide user feedback for all operations
- [ ] Test with insufficient credits
- [ ] Test with zero balance
- [ ] Test transaction history
- [ ] Test real-time updates
- [ ] Implement retry logic
- [ ] Sanitize user inputs

### Common Patterns

1. **Pre-check**: Always verify balance before operations
2. **Optimistic Updates**: Update UI immediately, rollback on failure
3. **Transaction Context**: Include featureId and metadata in all operations
4. **Error Recovery**: Provide upgrade path when credits insufficient
5. **Real-time Sync**: Subscribe to credit changes for multi-device sync
6. **Audit Trail**: Maintain complete transaction history
7. **Caching**: Use TanStack Query for performance
8. **Validation**: Validate all inputs on both client and server

## Related Documentation

- **Credits Repository**: `infrastructure/repositories/README.md`
- **useCredits Hook**: `../../presentation/hooks/useCredits.md`
- **useDeductCredit Hook**: `../../presentation/hooks/useDeductCredit.md`
- **UserCredits Entity**: `domain/entities/README.md`
- **Transaction Errors**: `domain/errors/README.md`

## Domain Structure

```
src/domains/wallet/
├── domain/
│   ├── entities/           # Core entities
│   │   ├── UserCredits.ts
│   │   └── Transaction.ts
│   ├── value-objects/      # Value objects
│   └── errors/             # Domain errors
├── infrastructure/
│   ├── repositories/       # Data access
│   └── services/          # External services
└── presentation/
    ├── hooks/             # React hooks
    └── components/        # UI components
```
